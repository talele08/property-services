package org.egov.wcms.validator;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import org.egov.tracer.model.CustomException;
import org.egov.wcms.mdms.MDMSCache;
import org.egov.wcms.mdms.MDMSConstants;
import org.egov.wcms.mdms.MDMSUtils;
import org.egov.wcms.service.WaterConnectionService;
import org.egov.wcms.util.WaterConnectionServiceUtils;
import org.egov.wcms.web.models.Connection;
import org.egov.wcms.web.models.Document;
import org.egov.wcms.web.models.WaterConnectionReq;
import org.egov.wcms.web.models.WaterConnectionRes;
import org.egov.wcms.web.models.WaterConnectionSearchCriteria;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;

@Service
public class WaterConnectionValidator {
	
	@Autowired
	private WaterConnectionService waterConnectionService;
	
	@Autowired
	private MDMSCache mdmsCache;
	
	@Autowired
	private MDMSUtils mdmsUtils;
	
	@Autowired
	private WaterConnectionServiceUtils waterConnectionServiceUtils;

	/**
	 * Validates create request by performing the following validations:
	 * 1. All records must have same tenantId.
	 * 2. Create request must have atleast one connection object.
	 * 3. Check if the codes for applicationType, pipeSize and DocumentType are valid for every connection object
	 * 4. For every applicationType there is a specific set of documentTypes allowed, validate that.
	 * 
	 * We don check for duplicate record here since the ids are generated by the system and they don't repeat.
	 * 
	 * @param waterConnectionReq
	 */
	public void validateCreateRequest(WaterConnectionReq waterConnectionReq) {
		Map<String, String> errorMap = new HashMap<>();
		commonPreliminaryCheck(waterConnectionReq);
		validateMDMSCodes(waterConnectionReq, errorMap);
		if(!CollectionUtils.isEmpty(errorMap)) {
			throw new CustomException(errorMap);
		}
	}
		
	/**
	 * Validates update by performing the following validations:
	 * 1. All records must have same tenantId.
	 * 2. Atleast one record must be present in the update request
	 * 3. Check if the records exist in the db, otherwise, throw exception.
	 * 4. Check if the codes for applicationType, pipeSize and DocumentType are valid for every connection object
	 * 5. For every applicationType there is a specific set of documentTypes allowed, validate that.
	 * 
	 * @param connections
	 */
	public void validateUpdateRequest(WaterConnectionReq waterConnectionReq) {
		Map<String, String> errorMap = new HashMap<>();
		commonPreliminaryCheck(waterConnectionReq);
		checkIfRecordsExist(waterConnectionReq);
		validateMDMSCodes(waterConnectionReq, errorMap);
		if(!CollectionUtils.isEmpty(errorMap)) {
			throw new CustomException(errorMap);
		}
	}
	
	/**
	 * Performs preliminary checks for create flow, like:
	 * 1. All records must have same tenantId.
	 * 2. Request must have atleast one connection object.
	 * 
	 * @param waterConnectionReq
	 * @param errorMap
	 */
	public void commonPreliminaryCheck(WaterConnectionReq waterConnectionReq) {
	    Set<String> tenantIds = waterConnectionReq.getConnections().parallelStream()
				.map(Connection::getTenantId).collect(Collectors.toSet());
		//(1)
		if(tenantIds.size() > 1)
			throw new CustomException("MULTIPLE_TENANTS", "All records must have same tenantId");
		//
		// (2)
		if(waterConnectionReq.getConnections().isEmpty())
			throw new CustomException("INVALID_REQUEST", "Atleast one connection must be present");
		//
	}
	
	/**
	 * Validates various MDMS codes sent in the request as follows:
	 * 1. Check if the codes for applicationType, pipeSize and DocumentType are valid for every connection object
	 * 2. For every applicationType there is a specific set of documentTypes allowed, validates them.
	 * 
	 * @param waterConnectionReq
	 * @param errorMap
	 */
	public void validateMDMSCodes(WaterConnectionReq waterConnectionReq, Map<String, String> errorMap) {
		if(CollectionUtils.isEmpty(MDMSCache.mastersMap)) {
			String stateTenantId = waterConnectionReq.getConnections().get(0).getTenantId().split("[.]")[0];
			mdmsCache.buildCache(stateTenantId, waterConnectionReq.getRequestInfo());
		}
		for(Connection connection: waterConnectionReq.getConnections()) {
			// (1)
			if(!waterConnectionServiceUtils.getValidCodes(MDMSConstants.PIPESIZE_MASTER_NAME).contains(connection.getPipesize())) {
				errorMap.put("INVALID_PIPESIZE", "PIPESIZE code is invalid for connection: ");
			}
			// (1) (2)
			if(!waterConnectionServiceUtils.getValidCodes(MDMSConstants.APPLICATIONTYPE_MASTER_NAME).contains(connection.getApplicationType())) {
				errorMap.put("INVALID_APPLICATION_TYPE", "APPLICATION TYPE code is invalid for connection: ");
				continue;
			}
			List<String> validDocumentTypes = waterConnectionServiceUtils.getValidDocumentTypesForApplicationType(connection.getApplicationType());
			for(Document document: connection.getDocuments()) {
				if(!validDocumentTypes.contains(document.getDocumentType()))
					errorMap.put("INVALID_DOCUMENT_TYPE", "DOCUMENT TYPE code is invalid for document: "+document.getId());
			}
		}
	}
	
	/**
	 * Checks if the records sent in the update request exist in the system. Throws exception if any of them don't.
	 * 
	 * @param waterConnectionReq
	 */
	public void checkIfRecordsExist(WaterConnectionReq waterConnectionReq) {
		List<String> connectionNumbers = waterConnectionReq.getConnections().parallelStream()
				.map(Connection::getConnectionNumber).collect(Collectors.toList());

		WaterConnectionSearchCriteria waterConnectionSearchCriteria = WaterConnectionSearchCriteria.builder()
				.connectionNumber(connectionNumbers).tenantId(waterConnectionReq.getConnections().get(0).getTenantId()).build();
		WaterConnectionRes waterConnectionRes = waterConnectionService.getWaterConnections(waterConnectionSearchCriteria, waterConnectionReq.getRequestInfo());
		List<String> invalidConnections = new ArrayList<>();

		if(waterConnectionRes.getConnections().size() != connectionNumbers.size()) {
			List<String> searchResultconnectionNumbers = waterConnectionRes.getConnections().parallelStream()
					.map(Connection::getConnectionNumber).collect(Collectors.toList());
			for(String connection: connectionNumbers) {
				if(!searchResultconnectionNumbers.contains(connection))
					invalidConnections.add(connection);
			}
			throw new CustomException("INVALID_UPDATE_REQUEST", "Following connections do not exist: "+invalidConnections);
		}	
	}
	
	
	/**
	 * Performs preliminary checks for update flow, like:
	 * 1. All records must have same tenantId.
	 * 2. Create request must have atleast one connection object.
	 * 
	 * @param waterConnectionReq
	 * @param errorMap
	 */
	public void updatePreliminaryCheck(WaterConnectionReq waterConnectionReq) {
	    Set<String> tenantIds = waterConnectionReq.getConnections().parallelStream()
				.map(Connection::getTenantId).collect(Collectors.toSet());
		//(1)
		if(tenantIds.size() > 1)
			throw new CustomException("MULTIPLE_TENANTS", "All records must have same tenantId");
		// (2)
		if(waterConnectionReq.getConnections().isEmpty())
			throw new CustomException("INVALID_CREATE_REQUEST", "Atleast one connection must be present");
	}
	
	/**
	 * Validates search request performing the following validations:
	 * 
	 * @param WaterConnectionSearchCriteria
	 */
	public void validateSearchRequest(WaterConnectionSearchCriteria WaterConnectionSearchCriteria) {
		
	}
}
